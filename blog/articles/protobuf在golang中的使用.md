---
title: protobuf在golang中的使用
tags: go,program
grammar_cjkRuby: true
---

Google's data interchange format.
protobuf是谷歌的数据交换格式，相对于”encoding/gob“/特定协议/json/xml来说，protobuf紧凑，编解码速度快，适用于多语言平台，以及频繁通信且数据量大的场景。
proto2和proto3有一些区别，以前一直用的是proto2，比较明显的区别有：
- proto文件第一行声明版本
	syntax = "proto3";
- proto3移除“required”，“optional”改为“singular”
- proto3移除“default”选项，采用对应字段类型的默认值决定。
- proto3新增“Any”类型。
- proto3支持json映射。

---

### 环境准备
下载protoc
https://github.com/protocolbuffers/protobuf/releases
我们用的是centos，下载protoc-3.6.1-linux-x86_64.zip，解压，bin/protoc丢进/usr/local/bin/，include丢进/usr/local/include。

Go对于protobuf的支持包含两个部分，一个是protocol的编译器插件，其生成Go源码文件；另一个是包文件，实现了protobuf的encoding和decoding。

下载安装proto编译器插件
go get -u github.com/golang/protobuf/protoc-gen-go
protoc-gen-go会被安装在$GOBIN

下载安装Go protobuf包
go get github.com/golang/protobuf/proto

---

### 生成文件
使用的方式很简单。
protoc --go_out=. *.proto
--go_out参数设置Go源码文件的输出目录，生成的文件后缀是.pb.go

---

### 使用
创建文件test.proto
```pb
	syntax = "proto2";
	package example;

	enum FOO { X = 17; };

	message Test {
	  required string label = 1;
	  optional int32 type = 2 [default=77];
	  repeated int64 reps = 3;
	}
```
执行
```shell
protoc --go_out=. *.proto
```
得到test.pb.go
```golang
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: proto/test.proto

package example

import proto "github.com/golang/protobuf/proto"
...
```
测试文件main.go
```golang
package main

import (
	"log"

	"github.com/golang/protobuf/proto"
	"path/to/example"
)

func main() {
	test := &example.Test{
		Label: proto.String("hello"),
		Type:  proto.Int32(17),
		Reps:  []int64{1, 2, 3},
	}
	data, err := proto.Marshal(test)
	if err != nil {
		log.Fatal("marshaling error: ", err)
	}
	newTest := &example.Test{}
	err = proto.Unmarshal(data, newTest)
	if err != nil {
		log.Fatal("unmarshaling error: ", err)
	}
	// Now test and newTest contain the same data.
	if test.GetLabel() != newTest.GetLabel() {
		log.Fatalf("data mismatch %q != %q", test.GetLabel(), newTest.GetLabel())
	}
	// etc.
}
```
执行。

---

### 现实
实际在使用的时候，仅仅只凭一段数据而不知晓其他信息的前提下是无法进行解析的，因为不知道用什么样的struct去处理数据的映射，所以一般会在构造协议时加上一个cmd字段，用以标识这段数据的格式。

cmd可以是string，也可以是int，从节省空间的思路考虑，int相对比较合适。
- 简单的方法，直接将协议名hash成int。
- 复杂的方法，应用层的协议，一般都会分级分模块，模块名与协议名分别hash成short，hash后的模块id视为cmd的高16位，hash后的协议id视为cmd的低16位，最终映射成int。

代码参考[genProtoId](https://github.com/zhenzhongfu/toy/blob/master/script/genProtoId.go)





